\hypertarget{_s_d_l__mutex_8h}{}\doxysection{S\+D\+L/include/\+S\+D\+L\+\_\+mutex.h 파일 참조}
\label{_s_d_l__mutex_8h}\index{SDL/include/SDL\_mutex.h@{SDL/include/SDL\_mutex.h}}
{\ttfamily \#include \char`\"{}S\+D\+L\+\_\+stdinc.\+h\char`\"{}}\newline
{\ttfamily \#include \char`\"{}S\+D\+L\+\_\+error.\+h\char`\"{}}\newline
{\ttfamily \#include \char`\"{}begin\+\_\+code.\+h\char`\"{}}\newline
{\ttfamily \#include \char`\"{}close\+\_\+code.\+h\char`\"{}}\newline
\doxysubsection*{매크로}
\begin{DoxyCompactItemize}
\item 
\#define \mbox{\hyperlink{_s_d_l__mutex_8h_a1214610634c24465d7c50149752791a9}{S\+D\+L\+\_\+\+M\+U\+T\+E\+X\+\_\+\+T\+I\+M\+E\+D\+O\+UT}}~1
\item 
\#define \mbox{\hyperlink{_s_d_l__mutex_8h_abd2bc8605242c50341362ada961dc914}{S\+D\+L\+\_\+\+M\+U\+T\+E\+X\+\_\+\+M\+A\+X\+W\+A\+IT}}~($\sim$(Uint32)0)
\end{DoxyCompactItemize}
\doxysubsection*{Mutex functions}
\begin{DoxyCompactItemize}
\item 
\#define \mbox{\hyperlink{_s_d_l__mutex_8h_a3ce486805b5c21574466d3d93c908597}{S\+D\+L\+\_\+mutexP}}(m)~S\+D\+L\+\_\+\+Lock\+Mutex(m)
\item 
\#define \mbox{\hyperlink{_s_d_l__mutex_8h_aa25335079da2e776536c63e84288d684}{S\+D\+L\+\_\+mutexV}}(m)~S\+D\+L\+\_\+\+Unlock\+Mutex(m)
\item 
\mbox{\Hypertarget{_s_d_l__mutex_8h_ac085162a7cfb9ebd63e2d05d33c03c17}\label{_s_d_l__mutex_8h_ac085162a7cfb9ebd63e2d05d33c03c17}} 
typedef struct S\+D\+L\+\_\+mutex {\bfseries S\+D\+L\+\_\+mutex}
\item 
D\+E\+C\+L\+S\+P\+EC S\+D\+L\+\_\+mutex $\ast$S\+D\+L\+C\+A\+LL \mbox{\hyperlink{_s_d_l__mutex_8h_ae1f90ad6a7420fb3c4b5685e440d762f}{S\+D\+L\+\_\+\+Create\+Mutex}} (void)
\item 
\mbox{\Hypertarget{_s_d_l__mutex_8h_a0908c6a7356331d197059fbdc6c66a0f}\label{_s_d_l__mutex_8h_a0908c6a7356331d197059fbdc6c66a0f}} 
D\+E\+C\+L\+S\+P\+EC int S\+D\+L\+C\+A\+LL {\bfseries S\+D\+L\+\_\+\+Lock\+Mutex} (S\+D\+L\+\_\+mutex $\ast$mutex)
\item 
D\+E\+C\+L\+S\+P\+EC int S\+D\+L\+C\+A\+LL \mbox{\hyperlink{_s_d_l__mutex_8h_a5097fb4c7147d14a4c6df4515ec862e8}{S\+D\+L\+\_\+\+Try\+Lock\+Mutex}} (S\+D\+L\+\_\+mutex $\ast$mutex)
\item 
\mbox{\Hypertarget{_s_d_l__mutex_8h_afee1549c7723ebe13fbfca8ad94f8c9d}\label{_s_d_l__mutex_8h_afee1549c7723ebe13fbfca8ad94f8c9d}} 
D\+E\+C\+L\+S\+P\+EC int S\+D\+L\+C\+A\+LL {\bfseries S\+D\+L\+\_\+\+Unlock\+Mutex} (S\+D\+L\+\_\+mutex $\ast$mutex)
\item 
D\+E\+C\+L\+S\+P\+EC void S\+D\+L\+C\+A\+LL \mbox{\hyperlink{_s_d_l__mutex_8h_ad2bbcc4e32ac927af62f0cba671f63fe}{S\+D\+L\+\_\+\+Destroy\+Mutex}} (S\+D\+L\+\_\+mutex $\ast$mutex)
\end{DoxyCompactItemize}
\doxysubsection*{Semaphore functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{_s_d_l__mutex_8h_aa7d56df841e98eed229d1d4b17327d29}\label{_s_d_l__mutex_8h_aa7d56df841e98eed229d1d4b17327d29}} 
typedef struct S\+D\+L\+\_\+semaphore {\bfseries S\+D\+L\+\_\+sem}
\item 
D\+E\+C\+L\+S\+P\+EC S\+D\+L\+\_\+sem $\ast$S\+D\+L\+C\+A\+LL \mbox{\hyperlink{_s_d_l__mutex_8h_ab8c1a20a5466281a5d63a0cabe07e140}{S\+D\+L\+\_\+\+Create\+Semaphore}} (Uint32 initial\+\_\+value)
\item 
D\+E\+C\+L\+S\+P\+EC void S\+D\+L\+C\+A\+LL \mbox{\hyperlink{_s_d_l__mutex_8h_a23deb3b7e29a5137d804e4be3453a768}{S\+D\+L\+\_\+\+Destroy\+Semaphore}} (S\+D\+L\+\_\+sem $\ast$sem)
\item 
D\+E\+C\+L\+S\+P\+EC int S\+D\+L\+C\+A\+LL \mbox{\hyperlink{_s_d_l__mutex_8h_af51d75d18cb90f28b35c31e853b04792}{S\+D\+L\+\_\+\+Sem\+Wait}} (S\+D\+L\+\_\+sem $\ast$sem)
\item 
D\+E\+C\+L\+S\+P\+EC int S\+D\+L\+C\+A\+LL \mbox{\hyperlink{_s_d_l__mutex_8h_a517288aaa856ce2264e8420636e85c4a}{S\+D\+L\+\_\+\+Sem\+Try\+Wait}} (S\+D\+L\+\_\+sem $\ast$sem)
\item 
D\+E\+C\+L\+S\+P\+EC int S\+D\+L\+C\+A\+LL \mbox{\hyperlink{_s_d_l__mutex_8h_a4ea1acfaf722895626174e1e37c497da}{S\+D\+L\+\_\+\+Sem\+Wait\+Timeout}} (S\+D\+L\+\_\+sem $\ast$sem, Uint32 ms)
\item 
D\+E\+C\+L\+S\+P\+EC int S\+D\+L\+C\+A\+LL \mbox{\hyperlink{_s_d_l__mutex_8h_a0c50f774babf7a44c381238a1f780595}{S\+D\+L\+\_\+\+Sem\+Post}} (S\+D\+L\+\_\+sem $\ast$sem)
\item 
D\+E\+C\+L\+S\+P\+EC Uint32 S\+D\+L\+C\+A\+LL \mbox{\hyperlink{_s_d_l__mutex_8h_ae66390dca585fdab8de871fe32935768}{S\+D\+L\+\_\+\+Sem\+Value}} (S\+D\+L\+\_\+sem $\ast$sem)
\end{DoxyCompactItemize}
\doxysubsection*{Condition variable functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{_s_d_l__mutex_8h_ac50401d1b84d806a0c927c8cf454f96a}\label{_s_d_l__mutex_8h_ac50401d1b84d806a0c927c8cf454f96a}} 
typedef struct S\+D\+L\+\_\+cond {\bfseries S\+D\+L\+\_\+cond}
\item 
D\+E\+C\+L\+S\+P\+EC S\+D\+L\+\_\+cond $\ast$S\+D\+L\+C\+A\+LL \mbox{\hyperlink{_s_d_l__mutex_8h_ac729fb4dbfe4057452ebfc1087f61585}{S\+D\+L\+\_\+\+Create\+Cond}} (void)
\item 
D\+E\+C\+L\+S\+P\+EC void S\+D\+L\+C\+A\+LL \mbox{\hyperlink{_s_d_l__mutex_8h_a8843feeb270845e07fc23f692707540f}{S\+D\+L\+\_\+\+Destroy\+Cond}} (S\+D\+L\+\_\+cond $\ast$cond)
\item 
D\+E\+C\+L\+S\+P\+EC int S\+D\+L\+C\+A\+LL \mbox{\hyperlink{_s_d_l__mutex_8h_a1037a8274b0b13118fc78eeb417a1397}{S\+D\+L\+\_\+\+Cond\+Signal}} (S\+D\+L\+\_\+cond $\ast$cond)
\item 
D\+E\+C\+L\+S\+P\+EC int S\+D\+L\+C\+A\+LL \mbox{\hyperlink{_s_d_l__mutex_8h_a2ffd0b45ebdc44057007a59857ba46b3}{S\+D\+L\+\_\+\+Cond\+Broadcast}} (S\+D\+L\+\_\+cond $\ast$cond)
\item 
D\+E\+C\+L\+S\+P\+EC int S\+D\+L\+C\+A\+LL \mbox{\hyperlink{_s_d_l__mutex_8h_af759b2fe1c5507f47854c1edf1ecbabd}{S\+D\+L\+\_\+\+Cond\+Wait}} (S\+D\+L\+\_\+cond $\ast$cond, S\+D\+L\+\_\+mutex $\ast$mutex)
\item 
D\+E\+C\+L\+S\+P\+EC int S\+D\+L\+C\+A\+LL \mbox{\hyperlink{_s_d_l__mutex_8h_aa57013f95a9c608cf24a5100b841e863}{S\+D\+L\+\_\+\+Cond\+Wait\+Timeout}} (S\+D\+L\+\_\+cond $\ast$cond, S\+D\+L\+\_\+mutex $\ast$mutex, Uint32 ms)
\end{DoxyCompactItemize}


\doxysubsection{상세한 설명}
Functions to provide thread synchronization primitives. 

\doxysubsection{매크로 문서화}
\mbox{\Hypertarget{_s_d_l__mutex_8h_abd2bc8605242c50341362ada961dc914}\label{_s_d_l__mutex_8h_abd2bc8605242c50341362ada961dc914}} 
\index{SDL\_mutex.h@{SDL\_mutex.h}!SDL\_MUTEX\_MAXWAIT@{SDL\_MUTEX\_MAXWAIT}}
\index{SDL\_MUTEX\_MAXWAIT@{SDL\_MUTEX\_MAXWAIT}!SDL\_mutex.h@{SDL\_mutex.h}}
\doxysubsubsection{\texorpdfstring{SDL\_MUTEX\_MAXWAIT}{SDL\_MUTEX\_MAXWAIT}}
{\footnotesize\ttfamily \#define S\+D\+L\+\_\+\+M\+U\+T\+E\+X\+\_\+\+M\+A\+X\+W\+A\+IT~($\sim$(Uint32)0)}

This is the timeout value which corresponds to never time out. \mbox{\Hypertarget{_s_d_l__mutex_8h_a1214610634c24465d7c50149752791a9}\label{_s_d_l__mutex_8h_a1214610634c24465d7c50149752791a9}} 
\index{SDL\_mutex.h@{SDL\_mutex.h}!SDL\_MUTEX\_TIMEDOUT@{SDL\_MUTEX\_TIMEDOUT}}
\index{SDL\_MUTEX\_TIMEDOUT@{SDL\_MUTEX\_TIMEDOUT}!SDL\_mutex.h@{SDL\_mutex.h}}
\doxysubsubsection{\texorpdfstring{SDL\_MUTEX\_TIMEDOUT}{SDL\_MUTEX\_TIMEDOUT}}
{\footnotesize\ttfamily \#define S\+D\+L\+\_\+\+M\+U\+T\+E\+X\+\_\+\+T\+I\+M\+E\+D\+O\+UT~1}

Synchronization functions which can time out return this value if they time out. \mbox{\Hypertarget{_s_d_l__mutex_8h_a3ce486805b5c21574466d3d93c908597}\label{_s_d_l__mutex_8h_a3ce486805b5c21574466d3d93c908597}} 
\index{SDL\_mutex.h@{SDL\_mutex.h}!SDL\_mutexP@{SDL\_mutexP}}
\index{SDL\_mutexP@{SDL\_mutexP}!SDL\_mutex.h@{SDL\_mutex.h}}
\doxysubsubsection{\texorpdfstring{SDL\_mutexP}{SDL\_mutexP}}
{\footnotesize\ttfamily \#define S\+D\+L\+\_\+mutexP(\begin{DoxyParamCaption}\item[{}]{m }\end{DoxyParamCaption})~S\+D\+L\+\_\+\+Lock\+Mutex(m)}

Lock the mutex.

\begin{DoxyReturn}{반환값}
0, or -\/1 on error. 
\end{DoxyReturn}
\mbox{\Hypertarget{_s_d_l__mutex_8h_aa25335079da2e776536c63e84288d684}\label{_s_d_l__mutex_8h_aa25335079da2e776536c63e84288d684}} 
\index{SDL\_mutex.h@{SDL\_mutex.h}!SDL\_mutexV@{SDL\_mutexV}}
\index{SDL\_mutexV@{SDL\_mutexV}!SDL\_mutex.h@{SDL\_mutex.h}}
\doxysubsubsection{\texorpdfstring{SDL\_mutexV}{SDL\_mutexV}}
{\footnotesize\ttfamily \#define S\+D\+L\+\_\+mutexV(\begin{DoxyParamCaption}\item[{}]{m }\end{DoxyParamCaption})~S\+D\+L\+\_\+\+Unlock\+Mutex(m)}

Unlock the mutex.

\begin{DoxyReturn}{반환값}
0, or -\/1 on error.
\end{DoxyReturn}
\begin{DoxyWarning}{경고}
It is an error to unlock a mutex that has not been locked by the current thread, and doing so results in undefined behavior. 
\end{DoxyWarning}


\doxysubsection{함수 문서화}
\mbox{\Hypertarget{_s_d_l__mutex_8h_a2ffd0b45ebdc44057007a59857ba46b3}\label{_s_d_l__mutex_8h_a2ffd0b45ebdc44057007a59857ba46b3}} 
\index{SDL\_mutex.h@{SDL\_mutex.h}!SDL\_CondBroadcast@{SDL\_CondBroadcast}}
\index{SDL\_CondBroadcast@{SDL\_CondBroadcast}!SDL\_mutex.h@{SDL\_mutex.h}}
\doxysubsubsection{\texorpdfstring{SDL\_CondBroadcast()}{SDL\_CondBroadcast()}}
{\footnotesize\ttfamily D\+E\+C\+L\+S\+P\+EC int S\+D\+L\+C\+A\+LL S\+D\+L\+\_\+\+Cond\+Broadcast (\begin{DoxyParamCaption}\item[{S\+D\+L\+\_\+cond $\ast$}]{cond }\end{DoxyParamCaption})}

Restart all threads that are waiting on the condition variable.

\begin{DoxyReturn}{반환값}
0 or -\/1 on error. 
\end{DoxyReturn}
\mbox{\Hypertarget{_s_d_l__mutex_8h_a1037a8274b0b13118fc78eeb417a1397}\label{_s_d_l__mutex_8h_a1037a8274b0b13118fc78eeb417a1397}} 
\index{SDL\_mutex.h@{SDL\_mutex.h}!SDL\_CondSignal@{SDL\_CondSignal}}
\index{SDL\_CondSignal@{SDL\_CondSignal}!SDL\_mutex.h@{SDL\_mutex.h}}
\doxysubsubsection{\texorpdfstring{SDL\_CondSignal()}{SDL\_CondSignal()}}
{\footnotesize\ttfamily D\+E\+C\+L\+S\+P\+EC int S\+D\+L\+C\+A\+LL S\+D\+L\+\_\+\+Cond\+Signal (\begin{DoxyParamCaption}\item[{S\+D\+L\+\_\+cond $\ast$}]{cond }\end{DoxyParamCaption})}

Restart one of the threads that are waiting on the condition variable.

\begin{DoxyReturn}{반환값}
0 or -\/1 on error. 
\end{DoxyReturn}
\mbox{\Hypertarget{_s_d_l__mutex_8h_af759b2fe1c5507f47854c1edf1ecbabd}\label{_s_d_l__mutex_8h_af759b2fe1c5507f47854c1edf1ecbabd}} 
\index{SDL\_mutex.h@{SDL\_mutex.h}!SDL\_CondWait@{SDL\_CondWait}}
\index{SDL\_CondWait@{SDL\_CondWait}!SDL\_mutex.h@{SDL\_mutex.h}}
\doxysubsubsection{\texorpdfstring{SDL\_CondWait()}{SDL\_CondWait()}}
{\footnotesize\ttfamily D\+E\+C\+L\+S\+P\+EC int S\+D\+L\+C\+A\+LL S\+D\+L\+\_\+\+Cond\+Wait (\begin{DoxyParamCaption}\item[{S\+D\+L\+\_\+cond $\ast$}]{cond,  }\item[{S\+D\+L\+\_\+mutex $\ast$}]{mutex }\end{DoxyParamCaption})}

Wait on the condition variable, unlocking the provided mutex.

\begin{DoxyWarning}{경고}
The mutex must be locked before entering this function!
\end{DoxyWarning}
The mutex is re-\/locked once the condition variable is signaled.

\begin{DoxyReturn}{반환값}
0 when it is signaled, or -\/1 on error. 
\end{DoxyReturn}
\mbox{\Hypertarget{_s_d_l__mutex_8h_aa57013f95a9c608cf24a5100b841e863}\label{_s_d_l__mutex_8h_aa57013f95a9c608cf24a5100b841e863}} 
\index{SDL\_mutex.h@{SDL\_mutex.h}!SDL\_CondWaitTimeout@{SDL\_CondWaitTimeout}}
\index{SDL\_CondWaitTimeout@{SDL\_CondWaitTimeout}!SDL\_mutex.h@{SDL\_mutex.h}}
\doxysubsubsection{\texorpdfstring{SDL\_CondWaitTimeout()}{SDL\_CondWaitTimeout()}}
{\footnotesize\ttfamily D\+E\+C\+L\+S\+P\+EC int S\+D\+L\+C\+A\+LL S\+D\+L\+\_\+\+Cond\+Wait\+Timeout (\begin{DoxyParamCaption}\item[{S\+D\+L\+\_\+cond $\ast$}]{cond,  }\item[{S\+D\+L\+\_\+mutex $\ast$}]{mutex,  }\item[{Uint32}]{ms }\end{DoxyParamCaption})}

Waits for at most {\ttfamily ms} milliseconds, and returns 0 if the condition variable is signaled, \mbox{\hyperlink{_s_d_l__mutex_8h_a1214610634c24465d7c50149752791a9}{S\+D\+L\+\_\+\+M\+U\+T\+E\+X\+\_\+\+T\+I\+M\+E\+D\+O\+UT}} if the condition is not signaled in the allotted time, and -\/1 on error.

\begin{DoxyWarning}{경고}
On some platforms this function is implemented by looping with a delay of 1 ms, and so should be avoided if possible. 
\end{DoxyWarning}
\mbox{\Hypertarget{_s_d_l__mutex_8h_ac729fb4dbfe4057452ebfc1087f61585}\label{_s_d_l__mutex_8h_ac729fb4dbfe4057452ebfc1087f61585}} 
\index{SDL\_mutex.h@{SDL\_mutex.h}!SDL\_CreateCond@{SDL\_CreateCond}}
\index{SDL\_CreateCond@{SDL\_CreateCond}!SDL\_mutex.h@{SDL\_mutex.h}}
\doxysubsubsection{\texorpdfstring{SDL\_CreateCond()}{SDL\_CreateCond()}}
{\footnotesize\ttfamily D\+E\+C\+L\+S\+P\+EC S\+D\+L\+\_\+cond$\ast$ S\+D\+L\+C\+A\+LL S\+D\+L\+\_\+\+Create\+Cond (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})}

Create a condition variable.

Typical use of condition variables\+:

Thread A\+: S\+D\+L\+\_\+\+Lock\+Mutex(lock); while ( ! condition ) \{ S\+D\+L\+\_\+\+Cond\+Wait(cond, lock); \} S\+D\+L\+\_\+\+Unlock\+Mutex(lock);

Thread B\+: S\+D\+L\+\_\+\+Lock\+Mutex(lock); ... condition = true; ... S\+D\+L\+\_\+\+Cond\+Signal(cond); S\+D\+L\+\_\+\+Unlock\+Mutex(lock);

There is some discussion whether to signal the condition variable with the mutex locked or not. There is some potential performance benefit to unlocking first on some platforms, but there are some potential race conditions depending on how your code is structured.

In general it\textquotesingle{}s safer to signal the condition variable while the mutex is locked. \mbox{\Hypertarget{_s_d_l__mutex_8h_ae1f90ad6a7420fb3c4b5685e440d762f}\label{_s_d_l__mutex_8h_ae1f90ad6a7420fb3c4b5685e440d762f}} 
\index{SDL\_mutex.h@{SDL\_mutex.h}!SDL\_CreateMutex@{SDL\_CreateMutex}}
\index{SDL\_CreateMutex@{SDL\_CreateMutex}!SDL\_mutex.h@{SDL\_mutex.h}}
\doxysubsubsection{\texorpdfstring{SDL\_CreateMutex()}{SDL\_CreateMutex()}}
{\footnotesize\ttfamily D\+E\+C\+L\+S\+P\+EC S\+D\+L\+\_\+mutex$\ast$ S\+D\+L\+C\+A\+LL S\+D\+L\+\_\+\+Create\+Mutex (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})}

Create a mutex, initialized unlocked. \mbox{\Hypertarget{_s_d_l__mutex_8h_ab8c1a20a5466281a5d63a0cabe07e140}\label{_s_d_l__mutex_8h_ab8c1a20a5466281a5d63a0cabe07e140}} 
\index{SDL\_mutex.h@{SDL\_mutex.h}!SDL\_CreateSemaphore@{SDL\_CreateSemaphore}}
\index{SDL\_CreateSemaphore@{SDL\_CreateSemaphore}!SDL\_mutex.h@{SDL\_mutex.h}}
\doxysubsubsection{\texorpdfstring{SDL\_CreateSemaphore()}{SDL\_CreateSemaphore()}}
{\footnotesize\ttfamily D\+E\+C\+L\+S\+P\+EC S\+D\+L\+\_\+sem$\ast$ S\+D\+L\+C\+A\+LL S\+D\+L\+\_\+\+Create\+Semaphore (\begin{DoxyParamCaption}\item[{Uint32}]{initial\+\_\+value }\end{DoxyParamCaption})}

Create a semaphore, initialized with value, returns N\+U\+LL on failure. \mbox{\Hypertarget{_s_d_l__mutex_8h_a8843feeb270845e07fc23f692707540f}\label{_s_d_l__mutex_8h_a8843feeb270845e07fc23f692707540f}} 
\index{SDL\_mutex.h@{SDL\_mutex.h}!SDL\_DestroyCond@{SDL\_DestroyCond}}
\index{SDL\_DestroyCond@{SDL\_DestroyCond}!SDL\_mutex.h@{SDL\_mutex.h}}
\doxysubsubsection{\texorpdfstring{SDL\_DestroyCond()}{SDL\_DestroyCond()}}
{\footnotesize\ttfamily D\+E\+C\+L\+S\+P\+EC void S\+D\+L\+C\+A\+LL S\+D\+L\+\_\+\+Destroy\+Cond (\begin{DoxyParamCaption}\item[{S\+D\+L\+\_\+cond $\ast$}]{cond }\end{DoxyParamCaption})}

Destroy a condition variable. \mbox{\Hypertarget{_s_d_l__mutex_8h_ad2bbcc4e32ac927af62f0cba671f63fe}\label{_s_d_l__mutex_8h_ad2bbcc4e32ac927af62f0cba671f63fe}} 
\index{SDL\_mutex.h@{SDL\_mutex.h}!SDL\_DestroyMutex@{SDL\_DestroyMutex}}
\index{SDL\_DestroyMutex@{SDL\_DestroyMutex}!SDL\_mutex.h@{SDL\_mutex.h}}
\doxysubsubsection{\texorpdfstring{SDL\_DestroyMutex()}{SDL\_DestroyMutex()}}
{\footnotesize\ttfamily D\+E\+C\+L\+S\+P\+EC void S\+D\+L\+C\+A\+LL S\+D\+L\+\_\+\+Destroy\+Mutex (\begin{DoxyParamCaption}\item[{S\+D\+L\+\_\+mutex $\ast$}]{mutex }\end{DoxyParamCaption})}

Destroy a mutex. \mbox{\Hypertarget{_s_d_l__mutex_8h_a23deb3b7e29a5137d804e4be3453a768}\label{_s_d_l__mutex_8h_a23deb3b7e29a5137d804e4be3453a768}} 
\index{SDL\_mutex.h@{SDL\_mutex.h}!SDL\_DestroySemaphore@{SDL\_DestroySemaphore}}
\index{SDL\_DestroySemaphore@{SDL\_DestroySemaphore}!SDL\_mutex.h@{SDL\_mutex.h}}
\doxysubsubsection{\texorpdfstring{SDL\_DestroySemaphore()}{SDL\_DestroySemaphore()}}
{\footnotesize\ttfamily D\+E\+C\+L\+S\+P\+EC void S\+D\+L\+C\+A\+LL S\+D\+L\+\_\+\+Destroy\+Semaphore (\begin{DoxyParamCaption}\item[{S\+D\+L\+\_\+sem $\ast$}]{sem }\end{DoxyParamCaption})}

Destroy a semaphore. \mbox{\Hypertarget{_s_d_l__mutex_8h_a0c50f774babf7a44c381238a1f780595}\label{_s_d_l__mutex_8h_a0c50f774babf7a44c381238a1f780595}} 
\index{SDL\_mutex.h@{SDL\_mutex.h}!SDL\_SemPost@{SDL\_SemPost}}
\index{SDL\_SemPost@{SDL\_SemPost}!SDL\_mutex.h@{SDL\_mutex.h}}
\doxysubsubsection{\texorpdfstring{SDL\_SemPost()}{SDL\_SemPost()}}
{\footnotesize\ttfamily D\+E\+C\+L\+S\+P\+EC int S\+D\+L\+C\+A\+LL S\+D\+L\+\_\+\+Sem\+Post (\begin{DoxyParamCaption}\item[{S\+D\+L\+\_\+sem $\ast$}]{sem }\end{DoxyParamCaption})}

Atomically increases the semaphore\textquotesingle{}s count (not blocking).

\begin{DoxyReturn}{반환값}
0, or -\/1 on error. 
\end{DoxyReturn}
\mbox{\Hypertarget{_s_d_l__mutex_8h_a517288aaa856ce2264e8420636e85c4a}\label{_s_d_l__mutex_8h_a517288aaa856ce2264e8420636e85c4a}} 
\index{SDL\_mutex.h@{SDL\_mutex.h}!SDL\_SemTryWait@{SDL\_SemTryWait}}
\index{SDL\_SemTryWait@{SDL\_SemTryWait}!SDL\_mutex.h@{SDL\_mutex.h}}
\doxysubsubsection{\texorpdfstring{SDL\_SemTryWait()}{SDL\_SemTryWait()}}
{\footnotesize\ttfamily D\+E\+C\+L\+S\+P\+EC int S\+D\+L\+C\+A\+LL S\+D\+L\+\_\+\+Sem\+Try\+Wait (\begin{DoxyParamCaption}\item[{S\+D\+L\+\_\+sem $\ast$}]{sem }\end{DoxyParamCaption})}

Non-\/blocking variant of \mbox{\hyperlink{_s_d_l__mutex_8h_af51d75d18cb90f28b35c31e853b04792}{S\+D\+L\+\_\+\+Sem\+Wait()}}.

\begin{DoxyReturn}{반환값}
0 if the wait succeeds, \mbox{\hyperlink{_s_d_l__mutex_8h_a1214610634c24465d7c50149752791a9}{S\+D\+L\+\_\+\+M\+U\+T\+E\+X\+\_\+\+T\+I\+M\+E\+D\+O\+UT}} if the wait would block, and -\/1 on error. 
\end{DoxyReturn}
\mbox{\Hypertarget{_s_d_l__mutex_8h_ae66390dca585fdab8de871fe32935768}\label{_s_d_l__mutex_8h_ae66390dca585fdab8de871fe32935768}} 
\index{SDL\_mutex.h@{SDL\_mutex.h}!SDL\_SemValue@{SDL\_SemValue}}
\index{SDL\_SemValue@{SDL\_SemValue}!SDL\_mutex.h@{SDL\_mutex.h}}
\doxysubsubsection{\texorpdfstring{SDL\_SemValue()}{SDL\_SemValue()}}
{\footnotesize\ttfamily D\+E\+C\+L\+S\+P\+EC Uint32 S\+D\+L\+C\+A\+LL S\+D\+L\+\_\+\+Sem\+Value (\begin{DoxyParamCaption}\item[{S\+D\+L\+\_\+sem $\ast$}]{sem }\end{DoxyParamCaption})}

Returns the current count of the semaphore. \mbox{\Hypertarget{_s_d_l__mutex_8h_af51d75d18cb90f28b35c31e853b04792}\label{_s_d_l__mutex_8h_af51d75d18cb90f28b35c31e853b04792}} 
\index{SDL\_mutex.h@{SDL\_mutex.h}!SDL\_SemWait@{SDL\_SemWait}}
\index{SDL\_SemWait@{SDL\_SemWait}!SDL\_mutex.h@{SDL\_mutex.h}}
\doxysubsubsection{\texorpdfstring{SDL\_SemWait()}{SDL\_SemWait()}}
{\footnotesize\ttfamily D\+E\+C\+L\+S\+P\+EC int S\+D\+L\+C\+A\+LL S\+D\+L\+\_\+\+Sem\+Wait (\begin{DoxyParamCaption}\item[{S\+D\+L\+\_\+sem $\ast$}]{sem }\end{DoxyParamCaption})}

This function suspends the calling thread until the semaphore pointed to by {\ttfamily sem} has a positive count. It then atomically decreases the semaphore count. \mbox{\Hypertarget{_s_d_l__mutex_8h_a4ea1acfaf722895626174e1e37c497da}\label{_s_d_l__mutex_8h_a4ea1acfaf722895626174e1e37c497da}} 
\index{SDL\_mutex.h@{SDL\_mutex.h}!SDL\_SemWaitTimeout@{SDL\_SemWaitTimeout}}
\index{SDL\_SemWaitTimeout@{SDL\_SemWaitTimeout}!SDL\_mutex.h@{SDL\_mutex.h}}
\doxysubsubsection{\texorpdfstring{SDL\_SemWaitTimeout()}{SDL\_SemWaitTimeout()}}
{\footnotesize\ttfamily D\+E\+C\+L\+S\+P\+EC int S\+D\+L\+C\+A\+LL S\+D\+L\+\_\+\+Sem\+Wait\+Timeout (\begin{DoxyParamCaption}\item[{S\+D\+L\+\_\+sem $\ast$}]{sem,  }\item[{Uint32}]{ms }\end{DoxyParamCaption})}

Variant of \mbox{\hyperlink{_s_d_l__mutex_8h_af51d75d18cb90f28b35c31e853b04792}{S\+D\+L\+\_\+\+Sem\+Wait()}} with a timeout in milliseconds.

\begin{DoxyReturn}{반환값}
0 if the wait succeeds, \mbox{\hyperlink{_s_d_l__mutex_8h_a1214610634c24465d7c50149752791a9}{S\+D\+L\+\_\+\+M\+U\+T\+E\+X\+\_\+\+T\+I\+M\+E\+D\+O\+UT}} if the wait does not succeed in the allotted time, and -\/1 on error.
\end{DoxyReturn}
\begin{DoxyWarning}{경고}
On some platforms this function is implemented by looping with a delay of 1 ms, and so should be avoided if possible. 
\end{DoxyWarning}
\mbox{\Hypertarget{_s_d_l__mutex_8h_a5097fb4c7147d14a4c6df4515ec862e8}\label{_s_d_l__mutex_8h_a5097fb4c7147d14a4c6df4515ec862e8}} 
\index{SDL\_mutex.h@{SDL\_mutex.h}!SDL\_TryLockMutex@{SDL\_TryLockMutex}}
\index{SDL\_TryLockMutex@{SDL\_TryLockMutex}!SDL\_mutex.h@{SDL\_mutex.h}}
\doxysubsubsection{\texorpdfstring{SDL\_TryLockMutex()}{SDL\_TryLockMutex()}}
{\footnotesize\ttfamily D\+E\+C\+L\+S\+P\+EC int S\+D\+L\+C\+A\+LL S\+D\+L\+\_\+\+Try\+Lock\+Mutex (\begin{DoxyParamCaption}\item[{S\+D\+L\+\_\+mutex $\ast$}]{mutex }\end{DoxyParamCaption})}

Try to lock the mutex

\begin{DoxyReturn}{반환값}
0, S\+D\+L\+\_\+\+M\+U\+T\+E\+X\+\_\+\+T\+I\+M\+E\+D\+O\+UT, or -\/1 on error 
\end{DoxyReturn}
